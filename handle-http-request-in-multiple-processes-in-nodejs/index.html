<!doctype html><html><head>
<meta charset=utf-8>
<meta name=viewport content="width=device-width,initial-scale=1">
<meta name=description content="栖雲樓">
<link rel="shortcut icon" href=https://hujiale.me/favicon.ico>
<link rel=stylesheet href=/css/style.min.css>
<title>Handle HTTP request in multiple processes in NodeJS</title>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-Q50DZDP25S"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag('js',new Date),gtag('config','G-Q50DZDP25S',{anonymize_ip:!1})}</script>
</head>
<body><header id=banner>
<h2><a href=https://hujiale.me>栖雲樓</a></h2>
<nav>
<ul>
<li>
<a href=/ title=posts>posts</a>
</li><li>
<a href=/me/ title=me>me</a>
</li>
</ul>
</nav>
</header>
<main id=content>
<article>
<header id=post-header>
<h1>Handle HTTP request in multiple processes in NodeJS</h1>
<div>
Updated <time>January 10, 2022</time>
</div>
</header><p>NodeJS is single process based which is good at frequent IO operations. But single process can&rsquo;t fully utilize multi-core CPU. Luckily we have <code>child-process</code> module in NodeJS to spawn multiple processes. One of the practical examples is handling HTTP request, especially for a large number of concurrent requests. A common way is to use master-worker pattern, a master process working as a proxy to delegate the HTTP requests to child processes with load balance enabled. Cons of master-worker is rapid resource consuming as each process needs to listen on a different port. Another ninja way is to make each child process listen on the same port. Let&rsquo;s have a look at how to achieve that:</p>
<p><span class=more></span></p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=c1>// master.js
</span><span class=c1></span><span class=kd>var</span> <span class=nx>cp</span> <span class=o>=</span> <span class=nx>require</span><span class=p>(</span><span class=s1>&#39;child_process&#39;</span><span class=p>),</span>
    <span class=nx>cp1</span> <span class=o>=</span> <span class=nx>cp</span><span class=p>.</span><span class=nx>fork</span><span class=p>(</span><span class=s1>&#39;child-process.js&#39;</span><span class=p>),</span>
    <span class=nx>cp2</span> <span class=o>=</span> <span class=nx>cp</span><span class=p>.</span><span class=nx>fork</span><span class=p>(</span><span class=s1>&#39;child-process.js&#39;</span><span class=p>),</span>
    <span class=nx>net</span> <span class=o>=</span> <span class=nx>require</span><span class=p>(</span><span class=s1>&#39;net&#39;</span><span class=p>);</span>

<span class=kd>var</span> <span class=nx>server</span> <span class=o>=</span> <span class=nx>net</span><span class=p>.</span><span class=nx>createServer</span><span class=p>();</span> <span class=c1>// create a TCP server
</span><span class=c1></span>
<span class=nx>server</span><span class=p>.</span><span class=nx>on</span><span class=p>(</span><span class=s1>&#39;listening&#39;</span><span class=p>,</span> <span class=kd>function</span> <span class=p>()</span> <span class=p>{</span>
    <span class=cm>/**
</span><span class=cm>     * this is a tricky part
</span><span class=cm>     * it&#39;s not sending the whole server object
</span><span class=cm>     * but a stringified message object with server._handle in
</span><span class=cm>     * we will have another post to discuss it later
</span><span class=cm>     */</span>
    <span class=nx>cp1</span><span class=p>.</span><span class=nx>send</span><span class=p>(</span><span class=s1>&#39;server&#39;</span><span class=p>,</span> <span class=nx>server</span><span class=p>);</span>
    <span class=nx>cp2</span><span class=p>.</span><span class=nx>send</span><span class=p>(</span><span class=s1>&#39;server&#39;</span><span class=p>,</span> <span class=nx>server</span><span class=p>);</span>
    <span class=nx>server</span><span class=p>.</span><span class=nx>close</span><span class=p>();</span>
<span class=p>});</span>

<span class=nx>server</span><span class=p>.</span><span class=nx>listen</span><span class=p>(</span><span class=mi>1337</span><span class=p>);</span>

<span class=c1>// child.js
</span><span class=c1></span><span class=kd>var</span> <span class=nx>http</span> <span class=o>=</span> <span class=nx>require</span><span class=p>(</span><span class=s1>&#39;http&#39;</span><span class=p>);</span>

<span class=kd>var</span> <span class=nx>server</span> <span class=o>=</span> <span class=nx>http</span><span class=p>.</span><span class=nx>createServer</span><span class=p>(</span><span class=kd>function</span> <span class=p>(</span><span class=nx>req</span><span class=p>,</span> <span class=nx>res</span><span class=p>)</span> <span class=p>{</span>
   <span class=nx>res</span><span class=p>.</span><span class=nx>writeHead</span><span class=p>(</span><span class=mi>200</span><span class=p>,</span> <span class=p>{</span><span class=s1>&#39;Content-Type&#39;</span><span class=o>:</span> <span class=s1>&#39;text/plain&#39;</span><span class=p>});</span> 
   <span class=nx>res</span><span class=p>.</span><span class=nx>end</span><span class=p>(</span><span class=s1>&#39;handled by child, pid: &#39;</span> <span class=o>+</span> <span class=nx>process</span><span class=p>.</span><span class=nx>pid</span> <span class=o>+</span> <span class=s1>&#39;\n&#39;</span><span class=p>);</span>
<span class=p>});</span>

<span class=nx>process</span><span class=p>.</span><span class=nx>on</span><span class=p>(</span><span class=s1>&#39;message&#39;</span><span class=p>,</span> <span class=kd>function</span> <span class=p>(</span><span class=nx>m</span><span class=p>,</span> <span class=nx>tcpServer</span><span class=p>)</span> <span class=p>{</span>
   <span class=k>if</span> <span class=p>(</span><span class=nx>m</span> <span class=o>===</span> <span class=s1>&#39;server&#39;</span><span class=p>)</span> <span class=p>{</span>
      <span class=nx>tcpServer</span><span class=p>.</span><span class=nx>on</span><span class=p>(</span><span class=s1>&#39;connection&#39;</span><span class=p>,</span> <span class=kd>function</span> <span class=p>(</span><span class=nx>socket</span><span class=p>)</span> <span class=p>{</span>
          <span class=nx>server</span><span class=p>.</span><span class=nx>emit</span><span class=p>(</span><span class=s1>&#39;connection&#39;</span><span class=p>,</span> <span class=nx>socket</span><span class=p>);</span>
      <span class=p>});</span>
   <span class=p>}</span>
<span class=p>});</span>
</code></pre></div><p>In <code>master.js</code>, we create a TCP server, have it bound to port 1337, and close it immediately once delegate it to child process. In <code>child.js</code>, we create a HTTP server, not like usual, it doesn&rsquo;t listen on any port explicitly. Now we have the TCP server sent from master process (regard it to be the same TCP server instance for now, but actually not. We will discuss it in another post). Once there is connection to the TCP server, we manually emit the <code>connection</code> event on HTTP server with the TCP socket passed in. So that any HTTP reqeust to port 1337 will be handled by child process now, one process at a time. Let&rsquo;s use curl to check the result:</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash>$ curl http://localhost:1337
handled by child, pid: <span class=m>18169</span> 
$ curl http://localhost:1337
handled by child, pid: <span class=m>18168</span>
</code></pre></div></article>
</main><footer id=footer>
Copyright © 2022 hjl
</footer>
</body>
</html>