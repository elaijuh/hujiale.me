<!doctype html><html><head>
<meta charset=utf-8>
<meta name=viewport content="width=device-width,initial-scale=1">
<meta name=description content="栖雲樓">
<link rel="shortcut icon" href=https://hujiale.me/favicon.ico>
<link rel=stylesheet href=/css/style.min.css>
<title>Hoisting, what happens behind it</title>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-Q50DZDP25S"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag('js',new Date),gtag('config','G-Q50DZDP25S',{anonymize_ip:!1})}</script>
</head>
<body><header id=banner>
<h2><a href=https://hujiale.me>栖雲樓</a></h2>
<nav>
<ul>
<li>
<a href=/ title=posts>posts</a>
</li><li>
<a href=/me/ title=me>me</a>
</li>
</ul>
</nav>
</header>
<main id=content>
<article>
<header id=post-header>
<h1>Hoisting, what happens behind it</h1>
<div>
Updated <time>January 10, 2022</time>
</div>
</header><p>We always see the word <strong>hoisting</strong> in some javascript books and technical blogs. Hoisting is grabbed to explain the phenomenon that we can use a variable before we declare it. That&rsquo;s sound incredible in compiling languages, but in javascript it&rsquo;s really there. Some people might think that the interpretor do a magic to restructure the code and put all variable/function declaration statements at the top of the function body. Thinking like that way might help to write or read the program, but that&rsquo;s not the things truely happen behind. The post is to walk through the mechanism behind hoisting.</p>
<p><span class=more></span></p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=kd>function</span> <span class=nx>foo</span><span class=p>(</span><span class=nx>x</span><span class=p>)</span> <span class=p>{</span>
	<span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>x</span><span class=p>);</span> <span class=c1>// x
</span><span class=c1></span>	<span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>y</span><span class=p>);</span> <span class=c1>// undefined
</span><span class=c1></span>	<span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>z</span><span class=p>);</span> <span class=c1>// [function: z]
</span><span class=c1></span>
	<span class=nx>z</span><span class=p>();</span> <span class=c1>// z
</span><span class=c1></span>
	<span class=kd>var</span> <span class=nx>y</span> <span class=o>=</span> <span class=s1>&#39;y&#39;</span><span class=p>;</span>
	<span class=kd>var</span> <span class=nx>z</span> <span class=o>=</span> <span class=s1>&#39;z&#39;</span><span class=p>;</span>

	<span class=kd>function</span> <span class=nx>z</span><span class=p>()</span> <span class=p>{</span> <span class=c1>// overwrite var z
</span><span class=c1></span>		<span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s1>&#39;z&#39;</span><span class=p>);</span>
	<span class=p>}</span>
<span class=p>}</span>

<span class=nx>foo</span><span class=p>(</span><span class=s1>&#39;x&#39;</span><span class=p>);</span>
</code></pre></div><p>There are 3 kinds of scopes in javascript - <code>global scope</code>, <code>function scope</code>, <code>eval scope</code>. We only discuss function scope here. Whenever a function is invoked, the execution context is put on the top of the stack, and before executing the function code step-by-step, there is a pre-stage called <code>Declaration Binding Instantiation</code>. In this declaration binding stage, an <code>VariableEnvironment</code>(VE) (in old ECMA-262, it&rsquo;s refered as variable object) is created. Run-time function will refer to this <code>VariableEnvironment</code> (actually it should be <code>LexicalEnvironment</code> which is initialized the same as <code>VariableEnvironment</code>) to identify the variables. So below is what the declaration binding stage do in sequence</p>
<ol>
<li>Formal parameters are bound to VE</li>
<li>Function declaration is bound to VE. If the function name is already existing, it will overwrite it.</li>
<li><code>Arguments</code> is bound to VE.</li>
<li>Variable declaration is bound to VE. If the variable name is already existing, it will do nothing.</li>
</ol>
<p>VE for <code>foo</code> should look like:</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=cm>/*
</span><span class=cm>VE = {
</span><span class=cm>    x: &#39;x&#39;, // formal parameter x
</span><span class=cm>    z: [function z], // reference to function z
</span><span class=cm>    arguments:
</span><span class=cm>    y: undefined
</span><span class=cm>};
</span><span class=cm>*/</span>
</code></pre></div><p>So before the execution of the function, all variables/functions are bound to VE already to be later referenced. Now you know the magic behind hoisting.</p>
<hr>
<p><a href=http://www.ecma-international.org/ecma-262/5.1/#sec-10.5>http://www.ecma-international.org/ecma-262/5.1/#sec-10.5</a></p>
</article>
</main><footer id=footer>
Copyright © 2022 hjl
</footer>
</body>
</html>